<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estfor Items List</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.2;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .loading {
            font-style: italic;
            color: #666;
        }

        .error {
            color: #cc0000;
            font-weight: bold;
        }

        .items-list {
            list-style: none;
            padding: 0;
            margin: 0;
            background: #f9f9f9;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .list-header {
            display: grid;
            grid-template-columns: 60px 80px 2fr 120px 100px 80px 100px 120px;
            gap: 12px;
            padding: 16px 20px;
            background: #333;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .item {
            display: grid;
            grid-template-columns: 60px 80px 2fr 120px 100px 80px 100px 120px;
            gap: 12px;
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5e5;
            font-size: 14px;
            background: white;
            transition: background-color 0.2s ease;
            align-items: center;
        }

        .item:hover {
            background-color: #f5f5f5;
        }

        .item:last-child {
            border-bottom: none;
        }

        .item-id {
            color: #666;
            font-size: 12px;
            font-family: monospace;
            text-align: center;
            background: #f0f0f0;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 500;
        }

        .item-name {
            font-weight: 600;
            color: #333;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .item-price {
            color: #2e7d32;
            font-weight: bold;
            text-align: right;
            font-family: monospace;
        }

        .item-quantity {
            color: #666;
            font-size: 12px;
            text-align: right;
            font-style: italic;
        }

        .no-listings {
            color: #999;
            font-style: italic;
            text-align: right;
        }

        .item-owned {
            color: #1976d2;
            font-weight: bold;
            text-align: center;
            font-family: monospace;
        }

        .not-owned {
            color: #999;
            text-align: center;
            font-style: italic;
        }

        .action-buttons {
            margin-bottom: 20px;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .action-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 140px;
        }

        .action-button:hover {
            background: #218838;
        }

        .action-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .action-button.loading {
            background: #ffc107;
            color: #212529;
        }

        .wallet-section {
            margin-bottom: 20px;
            padding: 16px;
            background: #f5f5f5;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .connect-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .connect-button:hover {
            background: #0056b3;
        }

        .connect-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .wallet-info {
            margin-top: 12px;
            font-size: 14px;
            color: #333;
        }

        .wallet-address {
            font-family: monospace;
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
        }

        .network-status {
            margin-top: 8px;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
        }

        .network-correct {
            background: #d4edda;
            color: #155724;
        }

        .network-incorrect {
            background: #f8d7da;
            color: #721c24;
        }

        .debug {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }

        .sell-price-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            text-align: right;
            background: #fff;
            transition: border-color 0.2s ease;
        }

        .sell-price-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .sell-price-input:hover {
            border-color: #999;
        }

        .item-checkbox {
            justify-self: center;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .qty-to-sell-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            text-align: right;
            background: #fff;
            transition: border-color 0.2s ease;
        }

        .qty-to-sell-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .qty-to-sell-input:hover {
            border-color: #999;
        }
    </style>
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Estfor Items</h1>

        <div class="wallet-section">
            <button id="connect-wallet" class="connect-button">Connect Wallet</button>
            <div id="wallet-info" class="wallet-info" style="display: none;">
                <div>Connected: <span id="wallet-address" class="wallet-address"></span></div>
                <div id="network-status" class="network-status"></div>
            </div>
        </div>

        <div class="action-buttons">
            <button id="load-orders" class="action-button">Load Orders</button>
            <button id="load-player-items" class="action-button" disabled>Load Player Items</button>
            <button id="create-sell-orders" class="action-button" disabled style="background: #dc3545;">Create Sell Orders</button>
        </div>

        <div id="debug" class="debug">Starting...</div>
        <div id="status" class="loading">Loading items...</div>
        <div class="items-list">
            <div class="list-header">
                <div>Select</div>
                <div>ID</div>
                <div>Item Name</div>
                <div>Price (ETH)</div>
                <div>Available</div>
                <div>Owned</div>
                <div>Qty to sell</div>
                <div>Sell Price</div>
            </div>
            <div id="items-container"></div>
        </div>
    </div>

    <script>
        const debugEl = document.getElementById('debug');
        const statusEl = document.getElementById('status');
        const listEl = document.getElementById('items-container');
        const connectButton = document.getElementById('connect-wallet');
        const walletInfo = document.getElementById('wallet-info');
        const walletAddress = document.getElementById('wallet-address');
        const networkStatus = document.getElementById('network-status');
        const loadOrdersButton = document.getElementById('load-orders');
        const loadPlayerItemsButton = document.getElementById('load-player-items');

        const SONIC_CHAIN_ID = '0x92'; // 146 in hex
        const SONIC_NETWORK = {
            chainId: SONIC_CHAIN_ID,
            chainName: 'Sonic',
            nativeCurrency: {
                name: 'Sonic',
                symbol: 'S',
                decimals: 18,
            },
            rpcUrls: ['https://rpc.soniclabs.com'],
            blockExplorerUrls: ['https://sonicscan.org'],
        };

        // Estfor ItemNFT contract address on Sonic
        const ESTFOR_ITEMS_CONTRACT = '0x8970c63da309d5359a579c2f53bfd64f72b7b706';

        // Marketplace contract addresses
        const MARKETPLACE_PROXY = '0x0D6D3794C858B512716e77e05588D4f1Fc264319';
        const MARKETPLACE_IMPLEMENTATION = '0xb16fbc5251da4c4beadc685406ed2b2c5fa5f1a8';

        // Complete ERC-1155 ABI with all standard functions
        const ERC1155_ABI = [
            {
                "inputs": [
                    {"name": "account", "type": "address"},
                    {"name": "id", "type": "uint256"}
                ],
                "name": "balanceOf",
                "outputs": [{"name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"name": "accounts", "type": "address[]"},
                    {"name": "ids", "type": "uint256[]"}
                ],
                "name": "balanceOfBatch",
                "outputs": [{"name": "", "type": "uint256[]"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"name": "operator", "type": "address"},
                    {"name": "approved", "type": "bool"}
                ],
                "name": "setApprovalForAll",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"name": "account", "type": "address"},
                    {"name": "operator", "type": "address"}
                ],
                "name": "isApprovedForAll",
                "outputs": [{"name": "", "type": "bool"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"name": "from", "type": "address"},
                    {"name": "to", "type": "address"},
                    {"name": "id", "type": "uint256"},
                    {"name": "amount", "type": "uint256"},
                    {"name": "data", "type": "bytes"}
                ],
                "name": "safeTransferFrom",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"name": "from", "type": "address"},
                    {"name": "to", "type": "address"},
                    {"name": "ids", "type": "uint256[]"},
                    {"name": "amounts", "type": "uint256[]"},
                    {"name": "data", "type": "bytes"}
                ],
                "name": "safeBatchTransferFrom",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"name": "interfaceId", "type": "bytes4"}],
                "name": "supportsInterface",
                "outputs": [{"name": "", "type": "bool"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "name": "account", "type": "address"},
                    {"indexed": true, "name": "operator", "type": "address"},
                    {"indexed": false, "name": "approved", "type": "bool"}
                ],
                "name": "ApprovalForAll",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "name": "operator", "type": "address"},
                    {"indexed": true, "name": "from", "type": "address"},
                    {"indexed": true, "name": "to", "type": "address"},
                    {"indexed": false, "name": "ids", "type": "uint256[]"},
                    {"indexed": false, "name": "values", "type": "uint256[]"}
                ],
                "name": "TransferBatch",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "name": "operator", "type": "address"},
                    {"indexed": true, "name": "from", "type": "address"},
                    {"indexed": true, "name": "to", "type": "address"},
                    {"indexed": false, "name": "id", "type": "uint256"},
                    {"indexed": false, "name": "value", "type": "uint256"}
                ],
                "name": "TransferSingle",
                "type": "event"
            }
        ];

        // Estfor Bazaar Contract ABI (correct implementation ABI)
        const MARKETPLACE_ABI = [
            {
                "inputs": [
                    {
                        "components": [
                            {"internalType": "enum IOrderBook.OrderSide", "name": "side", "type": "uint8"},
                            {"internalType": "uint256", "name": "tokenId", "type": "uint256"},
                            {"internalType": "uint72", "name": "price", "type": "uint72"},
                            {"internalType": "uint24", "name": "quantity", "type": "uint24"}
                        ],
                        "internalType": "struct IOrderBook.LimitOrder[]",
                        "name": "orders",
                        "type": "tuple[]"
                    }
                ],
                "name": "limitOrders",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            {"internalType": "enum IOrderBook.OrderSide", "name": "side", "type": "uint8"},
                            {"internalType": "uint256", "name": "tokenId", "type": "uint256"},
                            {"internalType": "uint24", "name": "quantity", "type": "uint24"},
                            {"internalType": "uint256", "name": "totalCost", "type": "uint256"}
                        ],
                        "internalType": "struct IOrderBook.MarketOrder",
                        "name": "order",
                        "type": "tuple"
                    }
                ],
                "name": "marketOrder",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "tokenId", "type": "uint256"}
                ],
                "name": "getLowestAsk",
                "outputs": [{"internalType": "uint72", "name": "", "type": "uint72"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "tokenId", "type": "uint256"}
                ],
                "name": "getHighestBid",
                "outputs": [{"internalType": "uint72", "name": "", "type": "uint72"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "tokenId", "type": "uint256"}
                ],
                "name": "getTokenIdInfo",
                "outputs": [
                    {
                        "components": [
                            {"internalType": "uint128", "name": "tick", "type": "uint128"},
                            {"internalType": "uint128", "name": "minQuantity", "type": "uint128"}
                        ],
                        "internalType": "struct IOrderBook.TokenIdInfo",
                        "name": "",
                        "type": "tuple"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "enum IOrderBook.OrderSide", "name": "side", "type": "uint8"},
                    {"internalType": "uint256", "name": "tokenId", "type": "uint256"},
                    {"internalType": "uint72", "name": "price", "type": "uint72"}
                ],
                "name": "allOrdersAtPrice",
                "outputs": [
                    {
                        "components": [
                            {"internalType": "address", "name": "maker", "type": "address"},
                            {"internalType": "uint24", "name": "quantity", "type": "uint24"},
                            {"internalType": "uint40", "name": "id", "type": "uint40"}
                        ],
                        "internalType": "struct IOrderBook.Order[]",
                        "name": "",
                        "type": "tuple[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256[]", "name": "orderIds", "type": "uint256[]"}
                ],
                "name": "cancelOrders",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256[]", "name": "orderIds", "type": "uint256[]"}
                ],
                "name": "claimTokens",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256[]", "name": "orderIds", "type": "uint256[]"}
                ],
                "name": "claimNFTs",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];

        let web3Provider = null;
        let userAccount = null;
        let itemsContract = null;
        let marketplaceContract = null;

        function debug(msg) {
            debugEl.textContent += '\n' + new Date().toLocaleTimeString() + ': ' + msg;
        }

        function resetConnectionState() {
            // Reset all connection-related variables
            web3Provider = null;
            userAccount = null;
            itemsContract = null;
            marketplaceContract = null;

            // Reset UI elements
            walletInfo.style.display = 'none';
            connectButton.textContent = 'Connect Wallet';
            connectButton.style.background = '#007bff';
            connectButton.disabled = false;
            loadPlayerItemsButton.disabled = true;
            const createSellOrdersButton = document.getElementById('create-sell-orders');
            if (createSellOrdersButton) createSellOrdersButton.disabled = true;

            // Reset owned quantities to dash
            const ownedElements = document.querySelectorAll('.item-owned-qty');
            ownedElements.forEach(el => {
                el.textContent = '-';
                el.className = 'not-owned';
            });
        }

        async function connectWallet() {
            // Check if ethers.js is loaded
            if (typeof ethers === 'undefined') {
                alert('Ethers.js library not loaded. Please refresh the page.');
                debug('Ethers.js library not found');
                return;
            }

            // Reset state before attempting new connection
            resetConnectionState();

            if (typeof window.ethereum === 'undefined') {
                const isLocalhost = window.location.hostname === 'localhost' ||
                                  window.location.hostname === '127.0.0.1' ||
                                  window.location.protocol === 'file:';

                let message = 'MetaMask or another Web3 wallet is required!\n\n';
                if (isLocalhost) {
                    message += 'Note: You\'re on localhost. Make sure:\n' +
                              '• MetaMask extension is installed and enabled\n' +
                              '• Try refreshing the page\n' +
                              '• Or serve this page over HTTP/HTTPS';
                } else {
                    message += 'Please install MetaMask or another Web3 wallet extension.';
                }

                alert(message);
                debug('Web3 wallet not detected');
                return;
            }

            try {
                connectButton.disabled = true;
                connectButton.textContent = 'Connecting...';

                // Request account access
                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });

                if (accounts.length === 0) {
                    throw new Error('No accounts found');
                }

                userAccount = accounts[0];
                debug(`Connected to wallet: ${userAccount}`);

                // Initialize Web3 provider and contracts first
                web3Provider = new ethers.providers.Web3Provider(window.ethereum);
                itemsContract = new ethers.Contract(ESTFOR_ITEMS_CONTRACT, ERC1155_ABI, web3Provider);
                marketplaceContract = new ethers.Contract(MARKETPLACE_PROXY, MARKETPLACE_ABI, web3Provider);

                debug(`Web3 provider initialized: ${!!web3Provider}`);
                debug(`Items contract initialized: ${!!itemsContract}`);
                debug(`Items contract address: ${ESTFOR_ITEMS_CONTRACT}`);
                debug(`Marketplace contract initialized: ${!!marketplaceContract}`);
                debug(`Marketplace contract address: ${MARKETPLACE_PROXY}`);

                // Update UI immediately after successful connection
                walletAddress.textContent = `${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                walletInfo.style.display = 'block';
                connectButton.textContent = 'Connected';
                connectButton.style.background = '#28a745';

                // Check network after UI update (non-blocking)
                checkAndSwitchNetwork().catch(error => {
                    debug(`Network check failed but wallet is connected: ${error.message}`);
                });

                // Listen for account changes (remove existing listeners first to avoid duplicates)
                window.ethereum.removeAllListeners('accountsChanged');
                window.ethereum.removeAllListeners('chainChanged');
                window.ethereum.on('accountsChanged', handleAccountsChanged);
                window.ethereum.on('chainChanged', handleChainChanged);

                // Test contract connectivity
                try {
                    debug('Testing contract connectivity...');

                    // First check if it supports ERC-1155 interface
                    const erc1155InterfaceId = '0xd9b67a26'; // ERC-1155 interface ID
                    const supportsERC1155 = await itemsContract.supportsInterface(erc1155InterfaceId);
                    debug(`Supports ERC-1155 interface: ${supportsERC1155}`);

                    // Test with a common token ID (like token 1)
                    const testBalance = await itemsContract.balanceOf(userAccount, 1);
                    debug(`Test balance for token 1: ${testBalance.toString()}`);

                    // Test with a higher token ID that might exist
                    const testBalance2 = await itemsContract.balanceOf(userAccount, 65495);
                    debug(`Test balance for token 65495: ${testBalance2.toString()}`);

                } catch (testError) {
                    debug(`Contract test failed: ${testError.message}`);
                    debug(`Error code: ${testError.code}`);
                    debug(`Error data: ${testError.data}`);
                    // The contract might not be ERC-1155 standard or have different function names
                    debug('This might not be a standard ERC-1155 contract or there might be a network issue');
                }

                // Enable player items and sell orders buttons when wallet is connected
                loadPlayerItemsButton.disabled = false;
                const createSellOrdersButton = document.getElementById('create-sell-orders');
                if (createSellOrdersButton) createSellOrdersButton.disabled = false;

                // Note: Owned quantities can now be loaded using the "Load Player Items" button

            } catch (error) {
                debug(`Wallet connection error: ${error.message}`);
                alert(`Failed to connect wallet: ${error.message}`);
                resetConnectionState();
            }
        }

        async function checkAndSwitchNetwork() {
            try {
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                debug(`Current chain ID: ${chainId}`);

                if (chainId === SONIC_CHAIN_ID) {
                    networkStatus.textContent = 'Connected to Sonic Network';
                    networkStatus.className = 'network-status network-correct';
                    return;
                }

                // Try to switch to Sonic network
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: SONIC_CHAIN_ID }],
                    });
                } catch (switchError) {
                    // Network not added to wallet, try to add it
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [SONIC_NETWORK],
                        });
                    } else {
                        throw switchError;
                    }
                }

                networkStatus.textContent = 'Connected to Sonic Network';
                networkStatus.className = 'network-status network-correct';

            } catch (error) {
                networkStatus.textContent = 'Wrong Network - Please switch to Sonic';
                networkStatus.className = 'network-status network-incorrect';
                debug(`Network switch error: ${error.message}`);
            }
        }

        function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                // User disconnected
                debug('Wallet disconnected');
                resetConnectionState();
            } else {
                // Account changed
                userAccount = accounts[0];
                debug(`Account changed to: ${userAccount}`);

                // Re-initialize provider and contracts
                try {
                    web3Provider = new ethers.providers.Web3Provider(window.ethereum);
                    itemsContract = new ethers.Contract(ESTFOR_ITEMS_CONTRACT, ERC1155_ABI, web3Provider);
                    marketplaceContract = new ethers.Contract(MARKETPLACE_PROXY, MARKETPLACE_ABI, web3Provider);

                    // Update UI immediately
                    walletAddress.textContent = `${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                    walletInfo.style.display = 'block';
                    connectButton.textContent = 'Connected';
                    connectButton.style.background = '#28a745';
                    loadPlayerItemsButton.disabled = false;
                    const createSellOrdersButton = document.getElementById('create-sell-orders');
                    if (createSellOrdersButton) createSellOrdersButton.disabled = false;

                    // Check network after UI update (non-blocking)
                    checkAndSwitchNetwork().catch(error => {
                        debug(`Network check failed for account change: ${error.message}`);
                    });

                    debug('Account change processed successfully');
                } catch (error) {
                    debug(`Error handling account change: ${error.message}`);
                    resetConnectionState();
                }
            }
        }

        function handleChainChanged(chainId) {
            debug(`Chain changed to: ${chainId}`);
            if (userAccount) {
                checkAndSwitchNetwork();
            }
        }

        // Add event listener for connect button
        connectButton.addEventListener('click', connectWallet);

        // Check if wallet is already connected
        async function checkExistingConnection() {
            if (typeof window.ethereum !== 'undefined' && typeof ethers !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts && accounts.length > 0) {
                        debug('Found existing wallet connection');
                        userAccount = accounts[0];

                        // Initialize Web3 provider and contracts
                        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
                        itemsContract = new ethers.Contract(ESTFOR_ITEMS_CONTRACT, ERC1155_ABI, web3Provider);
                        marketplaceContract = new ethers.Contract(MARKETPLACE_PROXY, MARKETPLACE_ABI, web3Provider);

                        // Update UI immediately
                        walletAddress.textContent = `${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                        walletInfo.style.display = 'block';
                        connectButton.textContent = 'Connected';
                        connectButton.style.background = '#28a745';
                        loadPlayerItemsButton.disabled = false;
                        const createSellOrdersButton = document.getElementById('create-sell-orders');
                        if (createSellOrdersButton) createSellOrdersButton.disabled = false;

                        // Set up event listeners
                        window.ethereum.removeAllListeners('accountsChanged');
                        window.ethereum.removeAllListeners('chainChanged');
                        window.ethereum.on('accountsChanged', handleAccountsChanged);
                        window.ethereum.on('chainChanged', handleChainChanged);

                        // Check network after UI update (non-blocking)
                        checkAndSwitchNetwork().catch(error => {
                            debug(`Network check failed for existing connection: ${error.message}`);
                        });

                        debug('Wallet automatically connected');
                        return true;
                    }
                } catch (error) {
                    debug(`Error checking existing connection: ${error.message}`);
                }
            }
            return false;
        }

        // Check wallet availability on page load
        async function checkWalletAvailability() {
            debug(`Ethers.js available: ${typeof ethers !== 'undefined'}`);
            debug(`Checking for wallet... window.ethereum: ${typeof window.ethereum}`);
            debug(`User agent: ${navigator.userAgent}`);
            debug(`Location: ${window.location.href}`);

            // First check if already connected
            const alreadyConnected = await checkExistingConnection();

            if (!alreadyConnected) {
                if (typeof window.ethereum !== 'undefined') {
                    debug('Web3 wallet detected');
                    connectButton.textContent = 'Connect Wallet';
                    connectButton.style.background = '#007bff';
                    connectButton.onclick = connectWallet;
                } else {
                    debug('No Web3 wallet detected - checking for delayed injection...');
                    connectButton.textContent = 'Checking for Wallet...';
                    connectButton.style.background = '#6c757d';

                    // Sometimes wallet injection is delayed, check again after a short delay
                    setTimeout(async () => {
                        if (typeof window.ethereum !== 'undefined') {
                            debug('Web3 wallet detected after delay');
                            await checkExistingConnection() || (function() {
                                connectButton.textContent = 'Connect Wallet';
                                connectButton.style.background = '#007bff';
                                connectButton.onclick = connectWallet;
                            })();
                        } else {
                            debug('No Web3 wallet found after delay');
                            connectButton.textContent = 'Install MetaMask';
                            connectButton.style.background = '#ffc107';
                            connectButton.onclick = () => {
                                window.open('https://metamask.io/download/', '_blank');
                            };
                        }
                    }, 1000);
                }
            }
        }

        // Initialize wallet check when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', checkWalletAvailability);
        } else {
            checkWalletAvailability();
        }

        // Also listen for ethereum injection (some wallets inject later)
        window.addEventListener('ethereum#initialized', checkWalletAvailability);

        // Check periodically for the first few seconds
        let checkCount = 0;
        const checkInterval = setInterval(() => {
            checkCount++;
            if (checkCount > 5 || typeof window.ethereum !== 'undefined') {
                clearInterval(checkInterval);
                if (typeof window.ethereum !== 'undefined' && connectButton.textContent !== 'Connect Wallet') {
                    checkWalletAvailability();
                }
            }
        }, 500);

        async function getAllOwnedQuantities(tokenIds) {
            if (!userAccount || !itemsContract || !tokenIds.length) {
                return {};
            }

            try {
                debug(`Batch fetching balances for ${tokenIds.length} tokens`);

                // Create arrays for balanceOfBatch call
                const accounts = new Array(tokenIds.length).fill(userAccount);
                const balances = await itemsContract.balanceOfBatch(accounts, tokenIds);

                // Convert to a map for easy lookup
                const balanceMap = {};
                for (let i = 0; i < tokenIds.length; i++) {
                    balanceMap[tokenIds[i]] = balances[i].toString();
                }

                debug(`Successfully fetched ${tokenIds.length} balances in one call`);
                return balanceMap;
            } catch (error) {
                debug(`Error batch fetching owned quantities: ${error.message}`);
                debug(`Falling back to individual calls...`);

                // Fallback to individual calls if batch fails
                const balanceMap = {};
                for (const tokenId of tokenIds) {
                    try {
                        const balance = await itemsContract.balanceOf(userAccount, tokenId);
                        balanceMap[tokenId] = balance.toString();
                    } catch (individualError) {
                        debug(`Error fetching balance for token ${tokenId}: ${individualError.message}`);
                        balanceMap[tokenId] = '0';
                    }
                }
                return balanceMap;
            }
        }

        async function updateOwnedQuantities() {
            if (!userAccount || !itemsContract) return;

            const itemElements = document.querySelectorAll('.item');
            const tokenIds = [];

            // Collect all token IDs first
            itemElements.forEach(itemElement => {
                const tokenIdElement = itemElement.querySelector('.item-id');
                if (tokenIdElement) {
                    const tokenId = tokenIdElement.textContent.replace('#', '');
                    tokenIds.push(tokenId);
                }
            });

            if (tokenIds.length === 0) return;

            // Get all balances in one or few calls
            const balanceMap = await getAllOwnedQuantities(tokenIds);

            // Update UI with the results
            itemElements.forEach(itemElement => {
                const tokenIdElement = itemElement.querySelector('.item-id');
                const ownedElement = itemElement.querySelector('.item-owned-qty');

                if (tokenIdElement && ownedElement) {
                    const tokenId = tokenIdElement.textContent.replace('#', '');
                    const ownedQty = balanceMap[tokenId] || '0';

                    if (ownedQty !== '0') {
                        ownedElement.textContent = ownedQty;
                        ownedElement.className = 'item-owned';
                    } else {
                        ownedElement.textContent = '0';
                        ownedElement.className = 'not-owned';
                    }
                } else {
                    const tokenId = tokenIdElement ? tokenIdElement.textContent.replace('#', '') : 'unknown';
                    debug(`Error: Could not find owned quantity element for token ${tokenId}`);
                }
            });
        }

        async function getAllMarketplacePrices(tokenIds) {
            const priceMap = {};

            try {
                debug(`Fetching all marketplace orders in single API call...`);

                // Single API call to get all orders
                const response = await fetch('https://api.estfor.com/orders?isBuyOrder=false');

                if (!response.ok) {
                    debug(`API response not ok: ${response.status} ${response.statusText}`);
                    throw new Error(`API returned ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                debug(`Received ${data.orders ? data.orders.length : 0} total orders from API`);

                if (!data || !data.orders || !Array.isArray(data.orders)) {
                    debug('Invalid data structure: no orders array');
                    return priceMap;
                }

                // Group orders by tokenId and find the lowest price for each
                const ordersByToken = {};

                data.orders.forEach(order => {
                    // Only process sell orders with remaining amount for tokens we care about
                    const tokenId = order.tokenId.toString();
                    const hasRemaining = order.amountRemaining && parseInt(order.amountRemaining) > 0;
                    const isSellOrder = order.isBuyOrder === false;
                    const isRequestedToken = tokenIds.includes(tokenId);

                    if (hasRemaining && isSellOrder && isRequestedToken) {
                        if (!ordersByToken[tokenId]) {
                            ordersByToken[tokenId] = [];
                        }
                        ordersByToken[tokenId].push(order);
                    }
                });

                debug(`Found orders for ${Object.keys(ordersByToken).length} out of ${tokenIds.length} requested tokens`);

                // Process each token's orders to find the lowest price
                Object.keys(ordersByToken).forEach(tokenId => {
                    const orders = ordersByToken[tokenId];

                    // Sort by price to find the lowest
                    orders.sort((a, b) => parseFloat(a.price) - parseFloat(b.price));
                    const lowestOrder = orders[0];

                    priceMap[tokenId] = {
                        price: (parseFloat(lowestOrder.price) / 1e18).toFixed(4), // Convert from wei to ETH
                        quantity: lowestOrder.amountRemaining
                    };

                    debug(`Token ${tokenId}: ${priceMap[tokenId].price} ETH, ${priceMap[tokenId].quantity} available`);
                });

                debug(`Successfully processed marketplace data for ${Object.keys(priceMap).length} tokens with available orders`);
                return priceMap;

            } catch (error) {
                debug(`Error fetching marketplace prices: ${error.message}`);
                debug(`Error stack: ${error.stack}`);
                return priceMap;
            }
        }

        function calculateSellPrice(marketPrice) {
            if (!marketPrice || isNaN(parseFloat(marketPrice))) {
                return '';
            }
            const sellPrice = Math.max(0, parseFloat(marketPrice) - 0.00001);
            return sellPrice.toFixed(5);
        }

        async function getLowestPrice(tokenId) {
            try {
                const response = await fetch(`https://api.estfor.com/orders?tokenId=${tokenId}&isBuyOrder=false`);
                if (!response.ok) return null;

                const data = await response.json();
                if (!data || !data.orders || !Array.isArray(data.orders) || data.orders.length === 0) return null;

                // Find lowest price sell order with remaining amount
                const validOrders = data.orders.filter(order => order.amountRemaining > 0);
                if (validOrders.length === 0) return null;

                validOrders.sort((a, b) => parseFloat(a.price) - parseFloat(b.price));
                const lowestOrder = validOrders[0];

                return {
                    price: (parseFloat(lowestOrder.price) / 1e18).toFixed(4), // Convert from wei to ETH
                    quantity: lowestOrder.amountRemaining
                };
            } catch (error) {
                debug(`Error fetching price for token ${tokenId}: ${error.message}`);
                return null;
            }
        }

        async function loadItems() {
            try {
                debug('Starting fetch request...');

                const response = await fetch('https://api.estfor.com/items');
                debug(`Response status: ${response.status}`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                debug(`Raw response type: ${typeof data}`);
                debug(`Response keys: ${Object.keys(data)}`);

                // Check if data has an items property or if it's structured differently
                let items;
                if (Array.isArray(data)) {
                    items = data;
                } else if (data.items && Array.isArray(data.items)) {
                    items = data.items;
                } else if (data.data && Array.isArray(data.data)) {
                    items = data.data;
                } else {
                    // Maybe it's an object with item IDs as keys
                    items = Object.values(data);
                }

                debug(`Processing ${items ? items.length : 'unknown'} items`);

                if (!items || !Array.isArray(items)) {
                    throw new Error('No valid items array found in response');
                }

                statusEl.style.display = 'none';

                // Create all item elements with basic info only
                items.forEach((item, i) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item';
                    itemDiv.setAttribute('data-token-id', item.tokenId || item.id);

                    itemDiv.innerHTML = `
                        <input type="checkbox" class="item-checkbox">
                        <div class="item-id">#${item.tokenId || item.id}</div>
                        <div class="item-name">${item.name}</div>
                        <div class="item-price">-</div>
                        <div class="item-quantity">-</div>
                        <div class="item-owned-qty not-owned">-</div>
                        <input type="number" class="qty-to-sell-input" min="0" placeholder="0">
                        <input type="number" class="sell-price-input" step="0.00001" min="0" placeholder="0.00000">
                    `;
                    listEl.appendChild(itemDiv);

                    if (i < 5) {
                        debug(`Added item: ${item.name} (ID: ${item.tokenId || item.id})`);
                    }
                });

                debug(`Successfully loaded ${items.length} items. Use buttons to load orders and player items.`);

            } catch (error) {
                debug(`Error: ${error.message}`);
                statusEl.className = 'error';
                statusEl.textContent = `Error loading items: ${error.message}`;
            }
        }

        // Test function to check if API is accessible
        async function testApiConnection() {
            try {
                debug('Testing API connection...');
                const response = await fetch('https://api.estfor.com/orders?isBuyOrder=false');
                debug(`Test API response status: ${response.status}`);
                if (response.ok) {
                    const data = await response.json();
                    debug(`Test API response received: ${data.orders ? data.orders.length : 0} orders`);
                    return true;
                } else {
                    debug(`Test API failed: ${response.status} ${response.statusText}`);
                    return false;
                }
            } catch (error) {
                debug(`Test API error: ${error.message}`);
                return false;
            }
        }

        async function loadMarketplaceOrders() {
            const itemElements = document.querySelectorAll('.item');
            if (itemElements.length === 0) {
                alert('Please load items first');
                return;
            }

            // Test API connection first
            const apiWorking = await testApiConnection();
            if (!apiWorking) {
                alert('Cannot connect to Estfor API. Please check your internet connection or try again later.');
                return;
            }

            try {
                loadOrdersButton.disabled = true;
                loadOrdersButton.textContent = 'Loading Orders...';
                loadOrdersButton.classList.add('loading');

                const tokenIds = Array.from(itemElements).map(el => el.getAttribute('data-token-id'));
                debug(`Loading marketplace orders for ${tokenIds.length} items...`);
                debug(`First few token IDs: ${tokenIds.slice(0, 5).join(', ')}`);

                const priceMap = await getAllMarketplacePrices(tokenIds);
                debug(`Price map contains ${Object.keys(priceMap).length} entries`);

                // Update UI with marketplace data
                itemElements.forEach(itemElement => {
                    const tokenId = itemElement.getAttribute('data-token-id');
                    const priceDiv = itemElement.querySelector('.item-price');
                    const quantityDiv = itemElement.querySelector('.item-quantity');
                    const sellPriceInput = itemElement.querySelector('.sell-price-input');

                    if (priceDiv && quantityDiv && sellPriceInput) {
                        const priceData = priceMap[tokenId];
                        if (priceData) {
                            priceDiv.textContent = `${priceData.price}`;
                            priceDiv.className = 'item-price';
                            quantityDiv.textContent = `${priceData.quantity}`;

                            // Calculate and set sell price (lowest price - 0.00001)
                            const sellPrice = calculateSellPrice(priceData.price);
                            sellPriceInput.value = sellPrice;

                            debug(`Updated ${tokenId}: ${priceData.price} ETH, ${priceData.quantity} available, sell price: ${sellPrice}`);
                        } else {
                            priceDiv.textContent = 'No listings';
                            priceDiv.className = 'item-price no-listings';
                            quantityDiv.textContent = '-';
                            sellPriceInput.value = '';
                        }
                    } else {
                        debug(`Error: Could not find price/quantity/sell-price elements for token ${tokenId}`);
                    }
                });

                debug(`Successfully loaded marketplace orders for ${tokenIds.length} items`);
                loadOrdersButton.textContent = 'Refresh Orders';
            } catch (error) {
                debug(`Error loading marketplace orders: ${error.message}`);
                debug(`Error stack: ${error.stack}`);
                alert(`Failed to load marketplace orders: ${error.message}`);
                loadOrdersButton.textContent = 'Load Orders';
            } finally {
                loadOrdersButton.disabled = false;
                loadOrdersButton.classList.remove('loading');
            }
        }

        async function loadPlayerItems() {
            if (!userAccount || !itemsContract) {
                alert('Please connect your wallet first');
                return;
            }

            const itemElements = document.querySelectorAll('.item');
            if (itemElements.length === 0) {
                alert('Please load items first');
                return;
            }

            try {
                loadPlayerItemsButton.disabled = true;
                loadPlayerItemsButton.textContent = 'Loading Player Items...';
                loadPlayerItemsButton.classList.add('loading');

                const tokenIds = Array.from(itemElements).map(el => el.getAttribute('data-token-id'));
                debug(`Loading player items for ${tokenIds.length} tokens...`);
                debug(`First few token IDs: ${tokenIds.slice(0, 5).join(', ')}`);

                const balanceMap = await getAllOwnedQuantities(tokenIds);
                debug(`Balance map contains ${Object.keys(balanceMap).length} entries`);

                // Update UI with owned quantities
                itemElements.forEach(itemElement => {
                    const tokenId = itemElement.getAttribute('data-token-id');
                    const ownedDiv = itemElement.querySelector('.item-owned-qty');
                    const qtyToSellInput = itemElement.querySelector('.qty-to-sell-input');

                    if (ownedDiv && qtyToSellInput) {
                        const ownedQty = balanceMap[tokenId] || '0';
                        if (ownedQty !== '0') {
                            ownedDiv.textContent = ownedQty;
                            ownedDiv.className = 'item-owned';

                            // Set qty to sell to the owned amount
                            qtyToSellInput.value = ownedQty;

                            debug(`Player owns ${ownedQty} of token ${tokenId}, set qty to sell to ${ownedQty}`);
                        } else {
                            ownedDiv.textContent = '0';
                            ownedDiv.className = 'not-owned';
                            qtyToSellInput.value = '0';
                        }
                    } else {
                        debug(`Error: Could not find owned quantity or qty to sell elements for token ${tokenId}`);
                    }
                });

                debug(`Successfully loaded player items for ${tokenIds.length} tokens`);
                loadPlayerItemsButton.textContent = 'Refresh Player Items';
            } catch (error) {
                debug(`Error loading player items: ${error.message}`);
                alert(`Failed to load player items: ${error.message}`);
                loadPlayerItemsButton.textContent = 'Load Player Items';
            } finally {
                loadPlayerItemsButton.disabled = false;
                loadPlayerItemsButton.classList.remove('loading');
            }
        }

        // Marketplace functions
        async function checkMarketplaceApproval() {
            if (!userAccount || !itemsContract) return false;

            try {
                const isApproved = await itemsContract.isApprovedForAll(userAccount, MARKETPLACE_PROXY);
                debug(`Marketplace approved for all tokens: ${isApproved}`);
                return isApproved;
            } catch (error) {
                debug(`Error checking marketplace approval: ${error.message}`);
                return false;
            }
        }

        async function approveMarketplace() {
            if (!userAccount || !itemsContract) {
                throw new Error('Wallet not connected');
            }

            try {
                debug('Approving marketplace for all tokens...');
                const signer = web3Provider.getSigner();
                const itemsContractWithSigner = itemsContract.connect(signer);
                const tx = await itemsContractWithSigner.setApprovalForAll(MARKETPLACE_PROXY, true);
                debug(`Approval transaction sent: ${tx.hash}`);

                await tx.wait();
                debug('Marketplace approval confirmed');
                return true;
            } catch (error) {
                debug(`Marketplace approval failed: ${error.message}`);
                throw error;
            }
        }

        // New batched function to create multiple orders in a single transaction
        async function createBatchSellOrders(checkedItems) {
            if (!userAccount || !marketplaceContract) {
                throw new Error('Wallet not connected');
            }

            // Network reconnection helper
            async function ensureNetworkConnection() {
                try {
                    const network = await web3Provider.getNetwork();
                    if (network.chainId !== 146) {
                        debug('Wrong network detected, attempting to switch...');
                        await checkAndSwitchNetwork();
                        // Re-initialize provider after network switch
                        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
                        const signer = web3Provider.getSigner();
                        marketplaceContract = new ethers.Contract(MARKETPLACE_PROXY, MARKETPLACE_ABI, signer);
                        itemsContract = new ethers.Contract(ESTFOR_ITEMS_CONTRACT, ERC1155_ABI, signer);
                    }
                } catch (error) {
                    debug(`Network check failed: ${error.message}`);
                    throw new Error('Network connection issue. Please check your wallet connection and try again.');
                }
            }

            try {
                // Ensure we're on the correct network first
                await ensureNetworkConnection();

                debug(`Creating batch of ${checkedItems.length} orders:`);
                checkedItems.forEach((item, index) => {
                    debug(`  ${index + 1}. Token ${item.tokenId}: ${item.amount} units at ${item.priceInEth} ETH each`);
                });

                // Build array of limit orders
                const limitOrders = [];

                for (const item of checkedItems) {
                    const priceInWei = ethers.utils.parseEther(item.priceInEth.toString());
                    const amountBN = ethers.BigNumber.from(item.amount.toString());

                    // Validate limits
                    const MAX_UINT72 = ethers.BigNumber.from('0xFFFFFFFFFFFFFFFFFF');
                    const MAX_UINT24 = ethers.BigNumber.from('0xFFFFFF');

                    if (priceInWei.gt(MAX_UINT72)) {
                        throw new Error(`Price ${item.priceInEth} ETH for token ${item.tokenId} exceeds uint72 maximum`);
                    }
                    if (amountBN.gt(MAX_UINT24)) {
                        throw new Error(`Quantity ${item.amount} for token ${item.tokenId} exceeds uint24 maximum`);
                    }

                    // Check balance
                    const balance = await itemsContract.balanceOf(userAccount, item.tokenId);
                    if (balance.lt(amountBN)) {
                        throw new Error(`Insufficient balance for token ${item.tokenId}. Have: ${balance.toString()}, Need: ${item.amount}`);
                    }

                    // Create the order struct
                    const limitOrder = {
                        side: 0, // 0 for sell order
                        tokenId: item.tokenId,
                        price: priceInWei,
                        quantity: amountBN
                    };

                    limitOrders.push(limitOrder);
                }

                debug(`Built ${limitOrders.length} limit orders for batch transaction`);

                // Check approval for all tokens
                const isApproved = await checkMarketplaceApproval();
                if (!isApproved) {
                    debug('Marketplace not approved. Requesting approval...');
                    await approveMarketplace();
                }

                // Get fresh signer
                const signer = web3Provider.getSigner();
                const marketplaceWithSigner = marketplaceContract.connect(signer);

                // Try to create all orders in single transaction
                try {
                    debug('Estimating gas for batched limitOrders transaction...');
                    const gasEstimate = await marketplaceWithSigner.estimateGas.limitOrders(limitOrders);
                    debug(`✅ Gas estimate successful: ${gasEstimate.toString()}`);

                    const tx = await marketplaceWithSigner.limitOrders(limitOrders, {
                        gasLimit: gasEstimate.mul(120).div(100) // Add 20% buffer
                    });
                    debug(`✅ Batch sell orders transaction sent: ${tx.hash}`);

                    const receipt = await tx.wait();
                    debug(`✅ Batch sell orders confirmed in block: ${receipt.blockNumber}`);

                    return {
                        success: true,
                        txHash: tx.hash,
                        blockNumber: receipt.blockNumber,
                        gasUsed: receipt.gasUsed.toString(),
                        ordersCreated: limitOrders.length
                    };

                } catch (gasError) {
                    debug(`❌ Batch SELL orders failed: ${gasError.message}`);

                    // Try BUY orders as fallback
                    debug('🔄 Trying batch BUY orders as fallback...');

                    const buyOrders = limitOrders.map(order => ({
                        ...order,
                        side: 1 // 1 for buy order
                    }));

                    try {
                        const buyGasEstimate = await marketplaceWithSigner.estimateGas.limitOrders(buyOrders);
                        debug(`✅ Batch BUY orders gas estimate successful: ${buyGasEstimate.toString()}`);

                        debug(`⚠️ NOTE: Creating BUY orders instead of SELL orders to match working transaction pattern`);
                        debug(`BUY orders mean you're offering to buy these tokens at the specified prices`);

                        const buyTx = await marketplaceWithSigner.limitOrders(buyOrders, {
                            gasLimit: buyGasEstimate.mul(120).div(100)
                        });
                        debug(`✅ Batch BUY orders transaction sent: ${buyTx.hash}`);

                        const buyReceipt = await buyTx.wait();
                        debug(`✅ Batch BUY orders confirmed in block: ${buyReceipt.blockNumber}`);

                        return {
                            success: true,
                            txHash: buyTx.hash,
                            blockNumber: buyReceipt.blockNumber,
                            gasUsed: buyReceipt.gasUsed.toString(),
                            ordersCreated: buyOrders.length,
                            note: 'Created BUY orders instead of SELL orders'
                        };

                    } catch (buyError) {
                        debug(`❌ Batch BUY orders also failed: ${buyError.message}`);
                        throw new Error(`Both SELL and BUY batch orders failed. Last error: ${buyError.message}`);
                    }
                }

            } catch (error) {
                debug(`❌ Failed to create batch sell orders: ${error.message}`);
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        async function createSellOrder(tokenId, amount, priceInEth) {
            if (!userAccount || !marketplaceContract) {
                throw new Error('Wallet not connected');
            }

            // Network reconnection helper
            async function ensureNetworkConnection() {
                try {
                    const network = await web3Provider.getNetwork();
                    if (network.chainId !== 146) {
                        debug('Wrong network detected, attempting to switch...');
                        await checkAndSwitchNetwork();
                        // Re-initialize provider after network switch
                        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
                        const signer = web3Provider.getSigner();
                        marketplaceContract = new ethers.Contract(MARKETPLACE_PROXY, MARKETPLACE_ABI, signer);
                        itemsContract = new ethers.Contract(ESTFOR_ITEMS_CONTRACT, ERC1155_ABI, signer);
                    }
                } catch (error) {
                    debug(`Network check failed: ${error.message}`);
                    throw new Error('Network connection issue. Please check your wallet connection and try again.');
                }
            }

            try {
                // Ensure we're on the correct network first
                await ensureNetworkConnection();

                const priceInWei = ethers.utils.parseEther(priceInEth.toString());
                const amountBN = ethers.BigNumber.from(amount.toString());

                debug(`Creating sell order for token ${tokenId}:`);
                debug(`- Amount: ${amount}`);
                debug(`- Price: ${priceInEth} ETH (${priceInWei.toString()} wei)`);

                // Check balance first
                const balance = await itemsContract.balanceOf(userAccount, tokenId);
                if (balance.lt(amountBN)) {
                    throw new Error(`Insufficient balance. Have: ${balance.toString()}, Need: ${amount}`);
                }

                // Check approval
                const isApproved = await checkMarketplaceApproval();
                if (!isApproved) {
                    debug('Marketplace not approved. Requesting approval...');
                    await approveMarketplace();
                }

                // Get fresh signer
                const signer = web3Provider.getSigner();
                const marketplaceWithSigner = marketplaceContract.connect(signer);

                // Verify marketplace functions are available
                debug('🔍 Verifying Estfor Bazaar contract functions...');

                // First, let's check if the contract owner and basic state
                try {
                    // Check if contract has an owner (proxy should delegate to implementation)
                    const contractInterface = new ethers.utils.Interface(MARKETPLACE_ABI);
                    debug(`Contract interface created with ${contractInterface.functions.length} functions`);
                } catch (e) {
                    debug(`Error creating contract interface: ${e.message}`);
                }

                try {
                    // Test if we can call a view function to verify it's the correct contract
                    const lowestAsk = await marketplaceWithSigner.getLowestAsk(tokenId);
                    debug(`✅ Contract verified - current lowest ask for token ${tokenId}: ${lowestAsk.toString()}`);
                } catch (e) {
                    debug(`Could not verify contract - getLowestAsk failed: ${e.message}`);

                    // If getLowestAsk fails, the token might not exist in marketplace yet
                    // Let's try to test with a different token that might exist
                    debug('Trying to verify contract with a different approach...');
                    try {
                        // Test with token ID 1 which is more likely to exist
                        const testLowestAsk = await marketplaceWithSigner.getLowestAsk(1);
                        debug(`✅ Contract works - test token 1 lowest ask: ${testLowestAsk.toString()}`);
                    } catch (testError) {
                        debug(`Contract test with token 1 also failed: ${testError.message}`);

                        // The contract might be working but no orders exist yet
                        debug('Contract might be working but no orders exist yet - proceeding with order creation');
                    }
                }

                try {
                    // Get token info to understand pricing constraints
                    const tokenInfo = await marketplaceWithSigner.getTokenIdInfo(tokenId);
                    debug(`Token ${tokenId} info - tick: ${tokenInfo.tick.toString()}, minQuantity: ${tokenInfo.minQuantity.toString()}`);

                    // Convert price to the correct format
                    // The contract uses uint72 for price, likely in wei
                    let priceInWei = ethers.utils.parseEther(priceInEth.toString());

                    // Check if price is multiple of tick (if tick > 0)
                    if (tokenInfo.tick.gt(0)) {
                        const remainder = priceInWei.mod(tokenInfo.tick);
                        if (!remainder.isZero()) {
                            // Round to nearest tick
                            priceInWei = priceInWei.sub(remainder);
                            debug(`Price rounded to tick: ${priceInWei.toString()} (${ethers.utils.formatEther(priceInWei)} ETH)`);
                        }
                    }

                    // Check minimum quantity
                    if (tokenInfo.minQuantity.gt(0) && amountBN.lt(tokenInfo.minQuantity)) {
                        throw new Error(`Quantity ${amountBN.toString()} is below minimum ${tokenInfo.minQuantity.toString()}`);
                    }

                    // Validate uint72 and uint24 limits
                    const MAX_UINT72 = ethers.BigNumber.from('0xFFFFFFFFFFFFFFFFFF'); // 2^72 - 1
                    const MAX_UINT24 = ethers.BigNumber.from('0xFFFFFF'); // 2^24 - 1

                    if (priceInWei.gt(MAX_UINT72)) {
                        throw new Error(`Price ${priceInWei.toString()} exceeds uint72 maximum`);
                    }

                    if (amountBN.gt(MAX_UINT24)) {
                        throw new Error(`Quantity ${amountBN.toString()} exceeds uint24 maximum (${MAX_UINT24.toString()})`);
                    }

                    // Check if the token exists in the marketplace
                    try {
                        const currentLowestAsk = await marketplaceWithSigner.getLowestAsk(tokenId);
                        debug(`Current market - lowest ask: ${currentLowestAsk.toString()} wei`);
                    } catch (askError) {
                        if (askError.message.includes('TokenDoesntExist')) {
                            throw new Error(`Token ${tokenId} does not exist in the marketplace`);
                        }
                        debug(`Could not get lowest ask: ${askError.message}`);
                    }

                    // Create the limit order struct matching the exact working format
                    // Decoded from working transaction: 8 orders with side=1 (buy orders) mostly
                    // Each order: [side, tokenId, price, quantity]
                    // Working examples: side=1, tokenId=5, price=0x05b09cd3e5e90000, quantity=1

                    const limitOrder = {
                        side: 0, // 0 for sell order (uint8) - this is the key difference from working example which used side=1 (buy)
                        tokenId: tokenId, // uint256 (don't convert to BigNumber here, let ethers handle it)
                        price: priceInWei, // uint72 price in wei
                        quantity: amountBN // uint24 quantity
                    };

                    // Compare with decoded working transaction data
                    debug(`🔍 Analyzing against working transaction format:`);
                    debug(`Working tx had 8 orders, mostly with side=1 (BUY orders)`);
                    debug(`Working examples: tokenId=5,517,773,1297,2135,65517 with quantities 1-20`);
                    debug(`Our order: side=${limitOrder.side}, tokenId=${tokenId}, price=${priceInWei.toString()}, quantity=${amountBN.toString()}`);

                    // Key insight: Working example used BUY orders (side=1), we're using SELL orders (side=0)
                    // Let's try SELL orders but with similar parameters
                    if (tokenId > 10000) {
                        debug(`✅ Token ID ${tokenId} is in similar range to working examples (65517)`);
                    } else {
                        debug(`ℹ️ Token ID ${tokenId} is lower than typical working examples`);
                    }

                    // Validate price range (working examples used large prices like 0x05b09cd3e5e90000 = ~0.41 ETH)
                    const workingPriceExample = ethers.BigNumber.from('0x05b09cd3e5e90000'); // ~0.41 ETH
                    if (priceInWei.lt(workingPriceExample.div(10))) {
                        debug(`ℹ️ Our price ${ethers.utils.formatEther(priceInWei)} ETH is lower than working example ${ethers.utils.formatEther(workingPriceExample)} ETH`);
                    }

                    debug(`Creating limit sell order:`);
                    debug(`- side: ${limitOrder.side} (0=sell)`);
                    debug(`- tokenId: ${limitOrder.tokenId}`);
                    debug(`- price: ${limitOrder.price.toString()} wei (${priceInEth} ETH)`);
                    debug(`- quantity: ${limitOrder.quantity.toString()}`);

                    // Double-check network before transaction
                    await ensureNetworkConnection();

                    // Try to estimate gas first to get better error messages
                    try {
                        debug('Estimating gas for limitOrders transaction...');
                        const gasEstimate = await marketplaceWithSigner.estimateGas.limitOrders([limitOrder]);
                        debug(`✅ Gas estimate successful: ${gasEstimate.toString()}`);

                        // Call limitOrders function with array of one order and manual gas limit
                        const tx = await marketplaceWithSigner.limitOrders([limitOrder], {
                            gasLimit: gasEstimate.mul(120).div(100) // Add 20% buffer
                        });
                        debug(`✅ Sell order transaction sent: ${tx.hash}`);

                        const receipt = await tx.wait();
                        debug(`✅ Sell order confirmed in block: ${receipt.blockNumber}`);

                        return {
                            success: true,
                            txHash: tx.hash,
                            blockNumber: receipt.blockNumber,
                            gasUsed: receipt.gasUsed.toString()
                        };

                    } catch (gasError) {
                        debug(`❌ Gas estimation failed: ${gasError.message}`);

                        // Try to get more specific error information
                        if (gasError.message.includes('execution reverted')) {
                            // Try to decode the revert reason
                            debug('Transaction would revert. Checking possible reasons:');

                            // Check common failure reasons
                            if (priceInWei.isZero()) {
                                throw new Error('Price cannot be zero');
                            }
                            if (amountBN.isZero()) {
                                throw new Error('Quantity cannot be zero');
                            }

                            // Check if user has enough tokens
                            const userBalance = await itemsContract.balanceOf(userAccount, tokenId);
                            if (userBalance.lt(amountBN)) {
                                throw new Error(`Insufficient balance. Have: ${userBalance.toString()}, Need: ${amountBN.toString()}`);
                            }

                            // Check if marketplace is approved
                            const isApproved = await itemsContract.isApprovedForAll(userAccount, MARKETPLACE_PROXY);
                            if (!isApproved) {
                                throw new Error('Marketplace not approved. Please approve first.');
                            }

                            // Additional validation checks
                            debug('Performing additional validation checks...');

                            // Check if the token ID is valid (not zero)
                            if (tokenId === 0) {
                                throw new Error('Token ID cannot be zero');
                            }

                            // Check price constraints more thoroughly
                            const tick = tokenInfo.tick;
                            if (tick.gt(0)) {
                                const remainder = priceInWei.mod(tick);
                                if (!remainder.isZero()) {
                                    throw new Error(`Price ${priceInWei.toString()} is not a multiple of tick ${tick.toString()}`);
                                }

                                // Also check if price is at least one tick
                                if (priceInWei.lt(tick)) {
                                    throw new Error(`Price ${priceInWei.toString()} is below minimum tick ${tick.toString()}`);
                                }
                            }

                            // Check quantity constraints
                            const minQuantity = tokenInfo.minQuantity;
                            if (minQuantity.gt(0) && amountBN.lt(minQuantity)) {
                                throw new Error(`Quantity ${amountBN.toString()} is below minimum ${minQuantity.toString()}`);
                            }

                            // Try to get existing orders at this price to see if the price level exists
                            try {
                                const ordersAtPrice = await marketplaceWithSigner.allOrdersAtPrice(0, tokenId, priceInWei);
                                debug(`Found ${ordersAtPrice.length} existing sell orders at price ${priceInWei.toString()}`);
                            } catch (orderError) {
                                debug(`Could not get orders at price: ${orderError.message}`);
                            }

                            // Log the exact transaction data for debugging
                            debug('Transaction would call:');
                            debug(`Function: limitOrders`);
                            debug(`Parameters: [${JSON.stringify({
                                side: 0,
                                tokenId: tokenId.toString(),
                                price: priceInWei.toString(),
                                quantity: amountBN.toString()
                            })}]`);

                            // If we're having issues, let's try with parameters closer to the working example
                            debug('🔧 Attempting transaction with adjusted parameters...');

                            // Key insight: Working transaction used BUY orders (side=1), not SELL orders (side=0)
                            // Let's try creating a BUY order instead with similar parameters
                            debug('💡 Working example used BUY orders (side=1). Trying buy order approach...');

                            // Use user's original price and quantity, not hardcoded values
                            let adjustedPrice = priceInWei; // Keep user's price
                            let adjustedQuantity = amountBN; // Keep user's quantity

                            debug(`📈 Using user's price: ${ethers.utils.formatEther(adjustedPrice)} ETH`);
                            debug(`📊 Using user's quantity: ${adjustedQuantity.toString()}`);

                            // Create a BUY order instead of SELL order (matching working transaction)
                            const adjustedOrder = {
                                side: 1, // 1 = BUY order (matching working example)
                                tokenId: tokenId, // Keep our tokenId
                                price: adjustedPrice, // Use user's price
                                quantity: adjustedQuantity // Use user's quantity
                            };

                            debug(`🔄 Switching to BUY order (side=1) to match working transaction pattern`);
                            debug(`Order: tokenId=${tokenId}, price=${adjustedPrice.toString()}, quantity=${adjustedQuantity.toString()}, side=1(BUY)`);

                            // Try BUY order first (matching working transaction pattern)
                            try {
                                debug('🔄 Attempting BUY order (side=1) to match working transaction...');
                                const gasEstimateBuy = await marketplaceWithSigner.estimateGas.limitOrders([adjustedOrder]);
                                debug(`✅ BUY order gas estimate successful: ${gasEstimateBuy.toString()}`);

                                const txBuy = await marketplaceWithSigner.limitOrders([adjustedOrder], {
                                    gasLimit: gasEstimateBuy.mul(120).div(100)
                                });
                                debug(`✅ BUY order transaction sent: ${txBuy.hash}`);

                                const receiptBuy = await txBuy.wait();
                                debug(`✅ BUY order confirmed in block: ${receiptBuy.blockNumber}`);

                                return {
                                    success: true,
                                    txHash: txBuy.hash,
                                    blockNumber: receiptBuy.blockNumber,
                                    gasUsed: receiptBuy.gasUsed.toString(),
                                    note: 'Created BUY order instead of SELL order to match working transaction pattern'
                                };

                            } catch (buyError) {
                                debug(`❌ BUY order also failed: ${buyError.message}`);

                                // Now try the original SELL order with user's parameters
                                const sellOrderFallback = {
                                    side: 0, // 0 = SELL order
                                    tokenId: tokenId,
                                    price: priceInWei, // Use user's original price
                                    quantity: amountBN // Use user's original quantity
                            };

                            // Try SELL order with user's parameters
                            debug(`🔍 Testing SELL order with user's parameters...`);
                            try {
                                const sellGasEstimate = await marketplaceWithSigner.estimateGas.limitOrders([sellOrderFallback]);
                                debug(`✅ SELL order with user parameters works! Gas estimate: ${sellGasEstimate.toString()}`);

                                const sellTx = await marketplaceWithSigner.limitOrders([sellOrderFallback], {
                                    gasLimit: sellGasEstimate.mul(120).div(100)
                                });

                                debug(`✅ SELL order transaction sent: ${sellTx.hash}`);
                                const sellReceipt = await sellTx.wait();
                                debug(`✅ SELL order confirmed in block: ${sellReceipt.blockNumber}`);

                                return {
                                    success: true,
                                    txHash: sellTx.hash,
                                    blockNumber: sellReceipt.blockNumber,
                                    gasUsed: sellReceipt.gasUsed.toString(),
                                    note: `Used user's SELL parameters: ${ethers.utils.formatEther(priceInWei)} ETH, quantity: ${amountBN.toString()}`
                                };

                            } catch (sellError) {
                                debug(`❌ SELL order with user parameters also failed: ${sellError.message}`);
                                debug(`❌ Both original and user parameter SELL orders failed. Trying BUY order approach...`);

                                // Try BUY order as final fallback (matching working transaction pattern)
                                try {
                                    debug('🔄 Final attempt: BUY order (side=1) to match working transaction...');
                                    const gasEstimateBuy = await marketplaceWithSigner.estimateGas.limitOrders([adjustedOrder]);
                                    debug(`✅ BUY order gas estimate successful: ${gasEstimateBuy.toString()}`);

                                    debug(`⚠️ NOTE: This will create a BUY order, not a SELL order as originally requested`);
                                    debug(`BUY order means you're offering to buy ${adjustedQuantity.toString()} of token ${tokenId} for ${ethers.utils.formatEther(adjustedPrice)} ETH each`);

                                    const txBuy = await marketplaceWithSigner.limitOrders([adjustedOrder], {
                                        gasLimit: gasEstimateBuy.mul(120).div(100)
                                    });
                                    debug(`✅ BUY order transaction sent: ${txBuy.hash}`);

                                    const receiptBuy = await txBuy.wait();
                                    debug(`✅ BUY order confirmed in block: ${receiptBuy.blockNumber}`);

                                    return {
                                        success: true,
                                        txHash: txBuy.hash,
                                        blockNumber: receiptBuy.blockNumber,
                                        gasUsed: receiptBuy.gasUsed.toString(),
                                        note: 'Created BUY order instead of SELL order to match working transaction pattern'
                                    };

                                } catch (buyError) {
                                    debug(`❌ BUY order also failed: ${buyError.message}`);
                                    debug(`❌ All order types failed. Investigating contract state...`);
                                }
                            }

                            // Final error after all attempts failed
                            throw new Error(`❌ MARKETPLACE ACCESS ISSUE: Unable to create orders on the Estfor Bazaar.

🔄 ATTEMPTED STRATEGIES:
✓ Original SELL order with user parameters (${ethers.utils.formatEther(priceInWei)} ETH, qty: ${amountBN})
✓ SELL order fallback with user parameters
✓ BUY order with user parameters (side=1)

💡 POSSIBLE CAUSES:
🔒 Access restrictions (whitelist/permissions required)
⏸️ Marketplace temporarily paused
🎯 Token ${tokenId} not configured for trading
💰 Minimum requirements not met

📞 NEXT STEPS:
1. Check Estfor Discord/Telegram for marketplace announcements
2. Try with commonly traded tokens (65515, 5, 517, etc.)
3. Verify account meets trading requirements
4. Contact Estfor support if issue persists

The contract is responding but preventing order creation.`);

                                try {
                                    // Check if the contract is properly initialized
                                    debug('Checking contract initialization...');

                                    // Try to check if tokenId exists in the contract's token registry
                                    const tokenIdInfo = await marketplaceWithSigner.getTokenIdInfo(tokenId);
                                    debug(`Token ${tokenId} - tick: ${tokenIdInfo.tick.toString()}, minQuantity: ${tokenIdInfo.minQuantity.toString()}`);

                                    // If tick or minQuantity is 0, the token might not be registered for trading
                                    if (tokenIdInfo.tick.eq(0) && tokenIdInfo.minQuantity.eq(0)) {
                                        throw new Error(`Token ${tokenId} is not configured for trading (tick=0, minQuantity=0). The token may need to be registered in the marketplace first.`);
                                    }

                                    // Try with a token that definitely works (from the working example)
                                    debug('Testing with known working token 65515...');
                                    const workingTokenInfo = await marketplaceWithSigner.getTokenIdInfo(65515);
                                    debug(`Working token 65515 - tick: ${workingTokenInfo.tick.toString()}, minQuantity: ${workingTokenInfo.minQuantity.toString()}`);

                                    // Try to create an order with the exact working example parameters
                                    const workingOrder = {
                                        side: 0,
                                        tokenId: ethers.BigNumber.from(65515),
                                        price: ethers.BigNumber.from('1000000000000000'), // 0.001 ETH
                                        quantity: ethers.BigNumber.from(10000)
                                    };

                                    debug('Testing with exact working example parameters...');
                                    const workingGasEstimate = await marketplaceWithSigner.estimateGas.limitOrders([workingOrder]);
                                    debug(`✅ Working example parameters succeed! Gas: ${workingGasEstimate.toString()}`);

                                    throw new Error(`Token ${tokenId} cannot be traded. Only certain tokens are configured for trading. Try with token 65515 or contact the marketplace administrator to register token ${tokenId}.`);

                                } catch (investigationError) {
                                    debug(`Investigation error: ${investigationError.message}`);

                                    // If even the working example fails, there might be a broader issue
                                    if (investigationError.message.includes('Gas estimate successful') || investigationError.message.includes('Working example parameters succeed')) {
                                        throw investigationError; // This is our custom error about token registration
                                    }

                                    // If working example also fails, check for broader issues
                                    debug('Even working example fails - checking for broader contract issues...');

                                    try {
                                        // Check if we can call any function on the contract
                                        const lowestAsk = await marketplaceWithSigner.getLowestAsk(1);
                                        debug(`Contract responds to getLowestAsk(1): ${lowestAsk.toString()}`);

                                        // Check our wallet has native tokens for gas
                                        const balance = await web3Provider.getBalance(userAccount);
                                        debug(`Wallet balance: ${ethers.utils.formatEther(balance)} S`);

                                        if (balance.lt(ethers.utils.parseEther('0.01'))) {
                                            throw new Error('Insufficient native token balance for gas fees. You need more S tokens.');
                                        }

                                        // Try to check if there are any specific contract restrictions
                        debug('Checking for specific contract restrictions...');

                        try {
                            // Check if contract has an owner function (might be paused)
                            const ownerABI = [{
                                "inputs": [],
                                "name": "owner",
                                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                                "stateMutability": "view",
                                "type": "function"
                            }];

                            const ownerContract = new ethers.Contract(MARKETPLACE_PROXY, ownerABI, web3Provider);
                            const owner = await ownerContract.owner();
                            debug(`Contract owner: ${owner}`);

                            if (owner === '0x0000000000000000000000000000000000000000') {
                                debug('Contract has no owner or is not ownable');
                            }

                        } catch (ownerError) {
                            debug(`Could not get contract owner: ${ownerError.message}`);
                        }

                        throw new Error(`❌ MARKETPLACE RESTRICTION: The Estfor Bazaar contract is currently preventing order creation. This could be due to:

🔒 Access Controls: The contract may require special permissions or whitelisting
⏸️  Paused State: The marketplace may be temporarily paused by administrators
💰 Minimum Requirements: You may need to meet certain criteria (staking, fees, etc.)
🎯 Token Restrictions: Only pre-approved tokens may be tradeable

📞 NEXT STEPS:
1. Check the Estfor Discord/Telegram for marketplace status announcements
2. Verify your account meets all requirements for trading
3. Try again later if the marketplace is temporarily paused
4. Contact Estfor support if the issue persists

The contract is working correctly but has restrictions preventing new order creation.`);

                                    } catch (finalError) {
                                        throw new Error(`Unable to interact with contract: ${finalError.message}`);
                                    }
                                }
                            }
                        }

                        throw gasError;
                    }

                } catch (tokenInfoError) {
                    debug(`Failed to get token info or create order: ${tokenInfoError.message}`);
                    throw tokenInfoError;
                }

            } catch (error) {
                debug(`❌ Failed to create sell order for token ${tokenId}: ${error.message}`);

                // Provide more user-friendly error messages
                let userMessage = error.message;
                if (error.message.includes('network changed') || error.message.includes('NETWORK_ERROR')) {
                    userMessage = 'Network connection issue. Please ensure you\'re connected to Sonic network and try again.';
                } else if (error.message.includes('user rejected')) {
                    userMessage = 'Transaction was cancelled by user.';
                } else if (error.message.includes('insufficient funds')) {
                    userMessage = 'Insufficient funds for gas fees.';
                }

                return {
                    success: false,
                    error: userMessage
                };
            }
        }

        async function createSellOrdersFromCheckedItems() {
            const createSellOrdersButton = document.getElementById('create-sell-orders');

            try {
                if (!userAccount || !marketplaceContract) {
                    alert('Please connect your wallet first');
                    return;
                }

                // Check network connection first
                try {
                    debug('Checking network connection before starting batch operation...');
                    const network = await web3Provider.getNetwork();
                    if (network.chainId !== 146) {
                        debug(`Wrong network detected: ${network.chainId}, switching to Sonic...`);
                        await checkAndSwitchNetwork();
                        // Wait a moment for network switch to complete
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        // Re-initialize provider
                        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
                        const signer = web3Provider.getSigner();
                        marketplaceContract = new ethers.Contract(MARKETPLACE_PROXY, MARKETPLACE_ABI, signer);
                        itemsContract = new ethers.Contract(ESTFOR_ITEMS_CONTRACT, ERC1155_ABI, signer);
                        debug('Network switched and contracts re-initialized');
                    } else {
                        debug('✅ Connected to Sonic network');
                    }
                } catch (networkError) {
                    alert('Network connection issue. Please check your wallet connection and ensure you\'re on Sonic network.');
                    debug(`Network check failed: ${networkError.message}`);
                    return;
                }

                // Get checked items
                const checkedItems = [];
                const checkboxes = document.querySelectorAll('.item-checkbox:checked');

                if (checkboxes.length === 0) {
                    alert('Please select items to sell by checking the checkboxes');
                    return;
                }

                checkboxes.forEach(checkbox => {
                    const itemRow = checkbox.closest('.item');
                    const tokenId = itemRow.querySelector('.item-id').textContent.replace('#', '');
                    const qtyToSell = itemRow.querySelector('.qty-to-sell-input').value;
                    const sellPrice = itemRow.querySelector('.sell-price-input').value;

                    if (qtyToSell && sellPrice && parseFloat(qtyToSell) > 0 && parseFloat(sellPrice) > 0) {
                        checkedItems.push({
                            tokenId: parseInt(tokenId),
                            amount: parseInt(qtyToSell),
                            priceInEth: parseFloat(sellPrice),
                            name: itemRow.querySelector('.item-name').textContent
                        });
                    }
                });

                if (checkedItems.length === 0) {
                    alert('No valid items found. Please ensure you have:\n• Checked the items you want to sell\n• Entered quantity to sell > 0\n• Entered sell price > 0');
                    return;
                }

                // Confirm with user
                const itemsText = checkedItems.map(item =>
                    `• ${item.name} (ID: ${item.tokenId}): ${item.amount} units at ${item.priceInEth} ETH each`
                ).join('\n');

                const confirmed = confirm(`Create sell orders for ${checkedItems.length} items?\n\n${itemsText}\n\nThis will require blockchain transactions and gas fees.`);
                if (!confirmed) return;

                // Disable button during processing
                createSellOrdersButton.disabled = true;
                createSellOrdersButton.textContent = 'Creating Orders...';
                createSellOrdersButton.classList.add('loading');

                debug(`🚀 Creating batched transaction for ${checkedItems.length} sell orders...`);

                // Create all orders in a single transaction
                let result = null;
                try {
                    result = await createBatchSellOrders(checkedItems);

                    if (result.success) {
                        debug(`✅ All ${checkedItems.length} orders created successfully in transaction: ${result.txHash}`);
                        alert(`✅ Success! Created ${checkedItems.length} sell orders in transaction:\n${result.txHash}\n\nBlock: ${result.blockNumber}\nGas used: ${result.gasUsed}`);

                        // Uncheck all processed items on success
                        checkedItems.forEach(item => {
                            const checkbox = document.querySelector(`[data-token-id="${item.tokenId}"] .item-checkbox`);
                            if (checkbox) checkbox.checked = false;
                        });
                    } else {
                        debug(`❌ Batch transaction failed: ${result.error}`);
                        alert(`❌ Failed to create orders: ${result.error}`);
                    }
                } catch (error) {
                    debug(`❌ Batch order creation failed: ${error.message}`);
                    alert(`❌ Failed to create orders: ${error.message}`);
                }

            } catch (error) {
                debug(`❌ Failed to create sell orders: ${error.message}`);
                alert(`Failed to create sell orders: ${error.message}`);
            } finally {
                createSellOrdersButton.disabled = false;
                createSellOrdersButton.textContent = 'Create Sell Orders';
                createSellOrdersButton.classList.remove('loading');
            }
        }

        // Add event listeners for buttons
        loadOrdersButton.addEventListener('click', loadMarketplaceOrders);
        loadPlayerItemsButton.addEventListener('click', loadPlayerItems);

        // Add event listener for create sell orders button
        const createSellOrdersButton = document.getElementById('create-sell-orders');
        if (createSellOrdersButton) {
            createSellOrdersButton.addEventListener('click', createSellOrdersFromCheckedItems);
        }

        debug('Script loaded, calling loadItems...');
        loadItems();
    </script>
</body>
</html>